#ifndef __MYCLASS_H__
#define __MYCLASS_H__

// Назовем объект данного класса родительским. Соответственно его класс родительским классом.
class MyClass {
  public:
    int publicProp; // одно свойство целого типа
  
    MyClass(int iPublic, int IPrivat) { // параметризированный конструктор, с двумя целочисленными параметрами
      publicProp = iPublic; // который устанавливает значения свойств в закрытом
      privateProp = IPrivat; // и открытом разделе
    };

    void change() { // метод с двумя целочисленными параметрами
      privateProp = IPrivat; // который устанавливает значения свойств в закрытом
      prublicProp = iPublic; // и открытом разделе
      
    void print() { // метод, который выводит на экран значение обоих свойств
      cout << privateProp << endl; // Сперва значение закрытого свойства
      cout << publicProp << endl; // потом значение открытого свойства
    }

  private:
    int privatProp; // одно свойство целого типа
    void privatChange() { // метод, с одним целочисленным параметром. который меняет значение свойства в закрытом разделе на удвоенное значение параметра
      privatProp = privatProp * 2;
    };

// На базе родительского объекта сконструируем производный объект. Производный объект должен сохранить открытый доступ к открытым элементам родительского класса. Он должен иметь следующие собственные элементы:

class MyClass2 {
  public:
    int publicProp; // одно свойство целого типа, наименование которого совпадает с наименование открытого свойства родительского объекта

    MyClass(int iPublic, int IPrivat) { // параметризированный конструктор, с двумя целочисленными параметрами, который устанавливает значения свойств в закрытом и открытом разделе
      publicProp = iPublic;
      privateProp = IPrivat; 
    };

    void change() { // метод с двумя целочисленными параметрами. Наименование метода совпадает с наименованием аналогичного метода родительского объекта
      privateProp = IPrivat; // который устанавливает значения свойств в закрытом
      prublicProp = iPublic; // и открытом разделе

     void print() { // метод, который выводит на экран значение обоих свойств. Наименование метода совпадает с наименованием аналогичного метода родительского объекта.
      cout << privateProp << endl; // Сперва значение закрытого свойства
      cout << publicProp << endl; // потом значение открытого свойства
    }
      
  private:
    int privatProp; // одно свойство целого типа, наименование которого совпадает с наименование закрытого свойства родительского объекта

}

  // Значение закрытого свойства меняется посредством вызова метода из закрытого раздела????
};

#endif